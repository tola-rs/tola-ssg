//! Embedded asset types with content-hash filenames.

use std::fs;
use std::marker::PhantomData;
use std::path::{Path, PathBuf};

use crate::config::cfg;

use super::TemplateVars;

/// Attribute marking tags generated by Tola
pub const GENERATED_ATTR: &str = "data-tola-generated";

/// Subdirectory for generated assets
const TOLA_DIR: &str = ".tola";

/// Get path_prefix from global config
fn path_prefix() -> PathBuf {
    cfg().build.path_prefix.clone()
}

/// Asset file type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AssetKind {
    Css,
    JavaScript,
}

impl AssetKind {
    pub const fn extension(&self) -> &'static str {
        match self {
            Self::Css => "css",
            Self::JavaScript => "js",
        }
    }
}

/// Embedded static asset with content-hash filename
#[derive(Debug, Clone)]
pub struct EmbeddedAsset<V = ()> {
    kind: AssetKind,
    name: &'static str,
    content: &'static str,
    _marker: PhantomData<V>,
}

impl<V> EmbeddedAsset<V> {
    pub const fn new(kind: AssetKind, name: &'static str, content: &'static str) -> Self {
        Self {
            kind,
            name,
            content,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub const fn content(&self) -> &'static str {
        self.content
    }

    /// Remove all versions of this asset file from output directory.
    pub fn cleanup_old(&self, output_dir: &Path) -> std::io::Result<()> {
        let tola_dir = output_dir.join(TOLA_DIR);
        if tola_dir.exists() {
            cleanup_all_versions(&tola_dir, self.name, self.kind.extension())
        } else {
            Ok(())
        }
    }
}

// =============================================================================
// EmbeddedAsset<()> - No variable injection
// =============================================================================

impl EmbeddedAsset<()> {
    /// Filename without hash (no variables to differentiate).
    pub fn filename(&self) -> String {
        format!("{}.{}", self.name, self.kind.extension())
    }

    /// URL path with path_prefix from config (e.g., "/prefix/.tola/enhance.css").
    pub fn url_path(&self) -> String {
        let prefix = path_prefix();
        let prefix_str = prefix.to_string_lossy();
        if prefix_str.is_empty() {
            format!("/{}/{}", TOLA_DIR, self.filename())
        } else {
            format!(
                "/{}/{}/{}",
                prefix_str.trim_matches('/'),
                TOLA_DIR,
                self.filename()
            )
        }
    }

    pub fn write_to(&self, output_dir: &Path) -> std::io::Result<PathBuf> {
        let tola_dir = output_dir.join(TOLA_DIR);
        let filename = self.filename();
        let path = tola_dir.join(&filename);
        fs::create_dir_all(&tola_dir)?;
        fs::write(&path, self.content)?;
        Ok(PathBuf::from(TOLA_DIR).join(filename))
    }

    #[allow(dead_code)]
    pub fn external_tag(&self) -> String {
        let url = self.url_path();
        match self.kind {
            AssetKind::Css => format!(
                r#"<link rel="stylesheet" href="{}" {}>"#,
                url, GENERATED_ATTR
            ),
            AssetKind::JavaScript => {
                format!(r#"<script src="{}" {}></script>"#, url, GENERATED_ATTR)
            }
        }
    }
}

// =============================================================================
// EmbeddedAsset<V> - With variable injection
// =============================================================================

impl<V: TemplateVars> EmbeddedAsset<V> {
    pub fn render(&self, vars: &V) -> String {
        vars.apply(self.content)
    }

    /// Filename with hash suffix if hash_input is non-empty.
    fn filename_with_vars(&self, vars: &V) -> String {
        let hash_input = vars.hash_input();
        if hash_input.is_empty() {
            format!("{}.{}", self.name, self.kind.extension())
        } else {
            let hash = crate::utils::hash::fingerprint(&hash_input);
            format!("{}-{}.{}", self.name, hash, self.kind.extension())
        }
    }

    /// URL path with path_prefix from config (e.g., "/prefix/.tola/spa-a1b2c3d4.js").
    pub fn url_path_with_vars(&self, vars: &V) -> String {
        let prefix = path_prefix();
        let prefix_str = prefix.to_string_lossy();
        if prefix_str.is_empty() {
            format!("/{}/{}", TOLA_DIR, self.filename_with_vars(vars))
        } else {
            format!(
                "/{}/{}/{}",
                prefix_str.trim_matches('/'),
                TOLA_DIR,
                self.filename_with_vars(vars)
            )
        }
    }

    pub fn write_with_vars(&self, output_dir: &Path, vars: &V) -> std::io::Result<PathBuf> {
        let tola_dir = output_dir.join(TOLA_DIR);
        let filename = self.filename_with_vars(vars);
        let path = tola_dir.join(&filename);
        fs::create_dir_all(&tola_dir)?;
        fs::write(&path, self.render(vars))?;
        Ok(PathBuf::from(TOLA_DIR).join(filename))
    }

    pub fn external_tag_with_vars(&self, vars: &V) -> String {
        let url = self.url_path_with_vars(vars);
        match self.kind {
            AssetKind::Css => format!(
                r#"<link rel="stylesheet" href="{}" {}>"#,
                url, GENERATED_ATTR
            ),
            AssetKind::JavaScript => {
                format!(r#"<script src="{}" {}></script>"#, url, GENERATED_ATTR)
            }
        }
    }
}

// =============================================================================
// Cleanup helper
// =============================================================================

/// Remove all versions of an asset file
/// Matches both `{name}.{ext}` and `{name}-*.{ext}` patterns
fn cleanup_all_versions(dir: &Path, name: &str, ext: &str) -> std::io::Result<()> {
    let base_name = format!("{}.{}", name, ext);
    let prefix = format!("{}-", name);
    let suffix = format!(".{}", ext);

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let file_name = entry.file_name();
        let name_str = file_name.to_string_lossy();

        // Delete {name}.{ext} or {name}-*.{ext}
        let is_base = name_str == base_name;
        let is_hashed = name_str.starts_with(&prefix) && name_str.ends_with(&suffix);
        if is_base || is_hashed {
            fs::remove_file(entry.path())?;
        }
    }

    Ok(())
}
